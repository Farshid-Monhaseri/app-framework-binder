/*
 Copyright 2015 IoT.bzh

 author: Jos√© Bollo <jose.bollo@iot.bzh>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/
#define _GNU_SOURCE

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <poll.h>
#include <assert.h>

#include <json.h>

#include "utils-sbus.h"
#include "utils-jbus.h"

/*
 * max depth of json messages
 */
#define MAX_JSON_DEPTH 10

/*
 * errors messages generated by jbus
 */
static const char out_of_memory_string[] = "out of memory";

/*
 * structure for services
 */
struct jservice {
	struct jservice *next;	/* link to the next service */
	char *method;		/* method name for the service */
	void (*oncall_s) (struct sbusmsg *, const char *, void *);
				/* string callback */
	void (*oncall_j) (struct sbusmsg *, struct json_object *, void *);
				/* json callback */
	void *data;		/* closure data for the callbacks */
};

/*
 * structure for signals
 */
struct jsignal {
	struct jsignal *next;	/* link to the next signal */
	char *name;		/* name of the expected signal */
	void (*onsignal_s) (const char *, void *);
				/* string callback */
	void (*onsignal_j) (struct json_object *, void *);
				/* json callback */
	void *data;		/* closure data for the callbacks */
};

/*
 * structure for asynchronous requests
 */
struct jrespw {
	struct jbus *jbus;
	void (*onresp) (int, struct json_object *, void *);
				/* json callback */
	void *data;		/* closure data for the callbacks */
};

/*
 * structure for handling either client or server jbus on dbus
 */
struct jbus {
	int refcount;			/* referenced how many time */
	struct sbus *sbus;
	struct sbus_service *sservice;
	struct sbus_signal *ssignal;
	struct json_tokener *tokener;	/* string to json tokenizer */
	struct jservice *services;	/* first service */
	struct jsignal *signals;	/* first signal */
	char *path;			/* dbus path */
	char *name;			/* dbus name */
};

/*********************** STATIC COMMON METHODS *****************/

/*
 * Replies the error "out of memory".
 * This function is intended to be used in services when an
 * allocation fails. Thus, it set errno to ENOMEM and
 * returns -1.
 */
static inline int reply_out_of_memory(struct sbusmsg *smsg)
{
	jbus_reply_error_s(smsg, out_of_memory_string);
	errno = ENOMEM;
	return -1;
}

/*
 * Parses the json-string 'msg' to create a json object stored
 * in 'obj'. It uses the tokener of 'jbus'. This is a small
 * improvement to avoid recreation of tokeners.
 *
 * Returns 1 in case of success and put the result in *'obj'.
 * Returns 0 in case of error and put NULL in *'obj'.
 */
static int jparse(struct jbus *jbus, const char *msg, struct json_object **obj)
{
	json_tokener_reset(jbus->tokener);
	*obj = json_tokener_parse_ex(jbus->tokener, msg, -1);
	if (json_tokener_get_error(jbus->tokener) == json_tokener_success)
		return 1;
	json_object_put(*obj);
	*obj = NULL;
	return 0;
}

static void on_service_call(struct sbusmsg *smsg, const char *content, struct jbus *jbus)
{
	struct jservice *service;
	const char *member;
	struct json_object *obj;

	member = sbus_member(smsg);
	service = jbus->services;
	while (service != NULL) {
		if (!strcmp(service->method, member)) {
			if (service->oncall_s)
				service->oncall_s(smsg, content, service->data);
			else if (service->oncall_j) {
				if (!jparse(jbus, content, &obj))
					obj = json_object_new_string(content);
				service->oncall_j(smsg, obj, service->data);
				json_object_put(obj);
			}
		}
		service = service->next;
	}
}

/*
 * Adds to 'jbus' a service of name 'method'. The service is
 * performed by one of the callback 'oncall_s' (for string) or
 * 'oncall_j' (for json) that will receive the request and the
 * closure parameter 'data'.
 *
 * returns 0 in case of success or -1 in case of error (ENOMEM).
 */
static int add_service(
		struct jbus *jbus,
		const char *method,
		void (*oncall_s) (struct sbusmsg *, const char *, void *),
		void (*oncall_j) (struct sbusmsg *, struct json_object *, void *),
		void *data)
{
	struct jservice *srv;

	/* connection of the service */
	if (jbus->sservice == NULL) {
		jbus->sservice = sbus_add_service(jbus->sbus,
				NULL, jbus->path, jbus->name, NULL,
				(void*)on_service_call, jbus);
		if (jbus->sservice == NULL)
			goto error;
	}

	/* allocation */
	srv = malloc(sizeof *srv);
	if (srv == NULL) {
		errno = ENOMEM;
		goto error;
	}
	srv->method = strdup(method);
	if (!srv->method) {
		errno = ENOMEM;
		goto error2;
	}

	/* record the service */
	srv->oncall_s = oncall_s;
	srv->oncall_j = oncall_j;
	srv->data = data;
	srv->next = jbus->services;
	jbus->services = srv;

	return 0;

 error2:
	free(srv);
 error:
	errno = ENOMEM;
	return -1;
}

static void on_signal_event(const struct sbusmsg *smsg, const char *content, struct jbus *jbus)
{
	struct jsignal *signal;
	const char *member;
	struct json_object *obj;

	member = sbus_member(smsg);
	signal = jbus->signals;
	while (signal != NULL) {
		if (!strcmp(signal->name, member)) {
			if (signal->onsignal_s)
				signal->onsignal_s(content, signal->data);
			else if (signal->onsignal_j) {
				if (!jparse(jbus, content, &obj))
					obj = json_object_new_string(content);
				signal->onsignal_j(obj, signal->data);
				json_object_put(obj);
			}
		}
		signal = signal->next;
	}
}

/*
 * Adds to 'jbus' a handler for the signal of 'name' emmited by
 * the sender and the interface that 'jbus' is linked to.
 * The signal is handled by one of the callback 'onsignal_s'
 * (for string) or 'onsignal_j' (for json) that will receive
 * parameters associated with the signal and the closure
 * parameter 'data'.
 *
 * returns 0 in case of success or -1 in case of error (ENOMEM).
 */
static int add_signal(
		struct jbus *jbus,
		const char *name,
		void (*onsignal_s) (const char *, void *),
		void (*onsignal_j) (struct json_object *, void *),
		void *data)
{
	struct jsignal *sig;

	/* connection of the signal */
	if (jbus->ssignal == NULL) {
		jbus->ssignal = sbus_add_signal(jbus->sbus,
				NULL, jbus->path, jbus->name, NULL,
				(void*)on_signal_event, jbus);
		if (jbus->ssignal == NULL)
			goto error;
	}

	/* allocation */
	sig = malloc(sizeof *sig);
	if (sig == NULL)
		goto error;
	sig->name = strdup(name);
	if (!sig->name)
		goto error2;

	/* record the signal */
	sig->onsignal_s = onsignal_s;
	sig->onsignal_j = onsignal_j;
	sig->data = data;
	sig->next = jbus->signals;
	jbus->signals = sig;

	return 0;

 error2:
	free(sig);
 error:
	errno = ENOMEM;
	return -1;
}

static void on_reply_j(int status, const char *reply, struct jrespw *jrespw)
{
	struct json_object *obj;

	if (!jparse(jrespw->jbus, reply, &obj))
		obj = json_object_new_string(reply);
	jrespw->onresp(status, obj, jrespw->data);
	json_object_put(obj);
	free(jrespw);
}

/*
 * Creates a message for 'method' with one string parameter being 'query'
 * and sends it to the destination, object and interface linked to 'jbus'.
 *
 * Adds to 'jbus' the response handler defined by the callbacks 'onresp_s'
 * (for string) and 'onresp_j' (for json) and the closure parameter 'data'.
 *
 * Returns 0 in case of success or -1 in case of error.
 */
static int call(
		struct jbus *jbus,
		const char *method,
		const char *query,
		void (*onresp_s) (int, const char *, void *),
		void (*onresp_j) (int, struct json_object *, void *),
		void *data)
{
	struct jrespw *resp;

	if (onresp_j == NULL)
		return sbus_call(jbus->sbus, jbus->name, jbus->path, jbus->name,
				method, query, onresp_s, data);

	/* allocates the response structure */
	resp = malloc(sizeof *resp);
	if (resp == NULL)
		goto error;

	/* fulfill the response structure */
	resp->jbus = jbus;
	resp->onresp = onresp_j;
	resp->data = data;
	if (sbus_call(jbus->sbus, jbus->name, jbus->path, jbus->name,
				method, query, (void*)on_reply_j, resp))
		goto error2;

	return 0;

 error2:
	free(resp);
 error:
	errno = ENOMEM;
	return -1;
}

/********************* MAIN FUNCTIONS *****************************************/

/*
 * Creates a 'jbus' bound the 'path' and it derived names and linked
 * either to the DBUS SYSTEM when 'session' is nul or to the DBUS SESSION
 * if 'session' is not nul.
 *
 * The parameter 'path' is intended to be the path of a DBUS single object.
 * Single means that it exists only one instance of the object on the
 * given bus. That path implies 2 derived DBUS names:
 *   1. the destination name of the program that handles the object
 *   2. the interface name of the object
 * These names are derived by removing the heading slash (/) and
 * by replacing all occurences of slashes by dots.
 * For example, passing path = /a/b/c means that the object /a/b/c is
 * handled by the destination a.b.c and replies to the interface a.b.c
 *
 * Returns the created jbus or NULL in case of error.
 */
struct jbus *create_jbus(struct sbus *sbus, const char *path)
{
	struct jbus *jbus;
	char *name;

	/* create the jbus object */
	jbus = calloc(1, sizeof *jbus);
	if (jbus == NULL) {
		errno = ENOMEM;
		goto error;
	}
	jbus->refcount = 1;

	/* create the tokener */
	jbus->tokener = json_tokener_new_ex(MAX_JSON_DEPTH);
	if (jbus->tokener == NULL) {
		errno = ENOMEM;
		goto error2;
	}

	/* records the path */
	jbus->path = strdup(path);
	if (jbus->path == NULL) {
		errno = ENOMEM;
		goto error2;
	}

	/* makes the name from the path */
	while (*path == '/')
		path++;
	jbus->name = name = strdup(path);
	if (name == NULL) {
		errno = ENOMEM;
		goto error2;
	}
	while (*name) {
		if (*name == '/')
			*name = '.';
		name++;
	}
	name--;
	while (name >= jbus->name && *name == '.')
		*name-- = 0;
	if (!*jbus->name) {
		errno = EINVAL;
		goto error2;
	}

	/* connect and init */
	jbus->sbus = sbus;

	return jbus;

 error2:
	jbus_unref(jbus);
 error:
	return NULL;
}

/*
 * Adds one reference to 'jbus'.
 */
void jbus_addref(struct jbus *jbus)
{
	jbus->refcount++;
}

/*
 * Removes one reference to 'jbus'. Destroys 'jbus' and it related
 * data if the count of references decrease to zero.
 */
void jbus_unref(struct jbus *jbus)
{
	struct jservice *srv;
	struct jsignal *sig;
	if (!--jbus->refcount) {
		while ((srv = jbus->services) != NULL) {
			jbus->services = srv->next;
			free(srv->method);
			free(srv);
		}
		while ((sig = jbus->signals) != NULL) {
			jbus->signals = sig->next;
			free(sig->name);
			free(sig);
		}
		if (jbus->sservice != NULL)
			sbus_remove_service(jbus->sbus, jbus->sservice);
		if (jbus->ssignal != NULL)
			sbus_remove_signal(jbus->sbus, jbus->ssignal);
		if (jbus->tokener != NULL)
			json_tokener_free(jbus->tokener);
		sbus_unref(jbus->sbus);
		free(jbus->name);
		free(jbus->path);
		free(jbus);
	}
}

/*
 * Replies an error of string 'error' to the request handled by 'smsg'.
 * Also destroys the request 'smsg' that must not be used later.
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_reply_error_s(struct sbusmsg *smsg, const char *error)
{
	return sbus_reply_error(smsg, error);
}

/*
 * Replies an error of json 'reply' to the request handled by 'smsg'.
 * Also destroys the request 'smsg' that must not be used later.
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_reply_error_j(struct sbusmsg *smsg, struct json_object *reply)
{
	const char *str = json_object_to_json_string(reply);
	return str ? jbus_reply_error_s(smsg, str) : reply_out_of_memory(smsg);
}

/*
 * Replies normally the string 'reply' to the request handled by 'smsg'.
 * Also destroys the request 'smsg' that must not be used later.
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_reply_s(struct sbusmsg *smsg, const char *reply)
{
	return sbus_reply(smsg, reply);
}

/*
 * Replies normally the json 'reply' to the request handled by 'smsg'.
 * Also destroys the request 'smsg' that must not be used later.
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_reply_j(struct sbusmsg *smsg, struct json_object *reply)
{
	const char *str = json_object_to_json_string(reply);
	return str ? jbus_reply_s(smsg, str) : reply_out_of_memory(smsg);
}

/*
 * Sends from 'jbus' the signal of 'name' handling the string 'content'.
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_send_signal_s(struct jbus *jbus, const char *name, const char *content)
{
	return sbus_send_signal(jbus->sbus, jbus->name, jbus->path, jbus->name, name, content);
}

/*
 * Sends from 'jbus' the signal of 'name' handling the json 'content'.
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_send_signal_j(struct jbus *jbus, const char *name,
		       struct json_object *content)
{
	const char *str = json_object_to_json_string(content);
	if (str == NULL) {
		errno = ENOMEM;
		return -1;
	}
	return jbus_send_signal_s(jbus, name, str);
}

/*
 * Adds to 'jbus' a service handling calls to the 'method' using
 * the "string" callback 'oncall' and the closure value 'data'.
 *
 * The callback 'oncall' is invoked for handling incoming method
 * calls. It receives 3 parameters:
 *   1. struct sbusmsg *: a handler to data to be used for replying
 *   2. const char *: the received string
 *   3. void *: the closure 'data' set by this function
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_add_service_s(
		struct jbus *jbus,
		const char *method,
		void (*oncall) (struct sbusmsg *, const char *, void *),
		void *data)
{
	return add_service(jbus, method, oncall, NULL, data);
}

/*
 * Adds to 'jbus' a service handling calls to the 'method' using
 * the "json" callback 'oncall' and the closure value 'data'.
 *
 * The callback 'oncall' is invoked for handling incoming method
 * calls. It receives 3 parameters:
 *   1. struct sbusmsg *: a handler to data to be used for replying
 *   2. struct json_object *: the received json
 *   3. void *: the closure 'data' set by this function
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_add_service_j(
		struct jbus *jbus,
		const char *method,
		void (*oncall) (struct sbusmsg *, struct json_object *, void *),
		void *data)
{
	return add_service(jbus, method, NULL, oncall, data);
}

/*
 * Start to serve: activate services declared for 'jbus'.
 * This function, in fact, declares 'jbus' as the receiver
 * for calls to the destination derived from the path set at
 * 'jbus' creation.
 * It also allows 'jbus' to emit signals of that origin.
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_start_serving(struct jbus *jbus)
{
	return sbus_add_name(jbus->sbus, jbus->name);
}

/*
 * Asynchronous call to 'method' of 'jbus' passing the string 'query'.
 * On response, the function 'onresp' is called with the returned string
 * value and the closure 'data'.
 * The function 'onresp' is invoked with 3 parameters:
 *   1. int: 0 if no error or -1 if error.
 *   2. const char *: the returned string (might be NULL if error)
 *   3. void *: the closure 'data'
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_call_ss(
		struct jbus *jbus,
		const char *method,
		const char *query,
		void (*onresp) (int, const char *, void *),
		void *data)
{
	return call(jbus, method, query, onresp, NULL, data);
}

/*
 * Asynchronous call to 'method' of 'jbus' passing the string 'query'.
 * On response, the function 'onresp' is called with the returned json
 * value and the closure 'data'.
 * The function 'onresp' is invoked with 3 parameters:
 *   1. int: 0 if no error or -1 if error.
 *   2. const char *: the returned json (might be NULL if error)
 *   3. void *: the closure 'data'
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_call_sj(
		struct jbus *jbus,
		const char *method,
		const char *query,
		void (*onresp) (int, struct json_object *, void *),
		void *data)
{
	return call(jbus, method, query, NULL, onresp, data);
}

/*
 * Asynchronous call to 'method' of 'jbus' passing the json 'query'.
 * On response, the function 'onresp' is called with the returned string
 * value and the closure 'data'.
 * The function 'onresp' is invoked with 3 parameters:
 *   1. int: 0 if no error or -1 if error.
 *   2. const char *: the returned string (might be NULL if error)
 *   3. void *: the closure 'data'
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_call_js(
		struct jbus *jbus,
		const char *method,
		struct json_object *query,
		void (*onresp) (int, const char *, void *),
		void *data)
{
	const char *str = json_object_to_json_string(query);
	if (str == NULL) {
		errno = ENOMEM;
		return -1;
	}
	return call(jbus, method, str, onresp, NULL, data);
}

/*
 * Asynchronous call to 'method' of 'jbus' passing the json 'query'.
 * On response, the function 'onresp' is called with the returned json
 * value and the closure 'data'.
 * The function 'onresp' is invoked with 3 parameters:
 *   1. int: 0 if no error or -1 if error.
 *   2. const char *: the returned json (might be NULL if error)
 *   3. void *: the closure 'data'
 *
 * Returns 0 in case of success or -1 in case of error.
 */
int jbus_call_jj(
		struct jbus *jbus,
		const char *method,
		struct json_object *query,
		void (*onresp) (int, struct json_object *, void *),
		void *data)
{
	const char *str = json_object_to_json_string(query);
	if (str == NULL) {
		errno = ENOMEM;
		return -1;
	}
	return call(jbus, method, str, NULL, onresp, data);
}

/*
 * Synchronous call to 'method' of 'jbus' passing the string 'query'.
 * The returned string response is returned.
 *
 * Returns the string response or NULL in case of error.
 */
char *jbus_call_ss_sync(
		struct jbus *jbus,
		const char *method,
		const char *query)
{
	return sbus_call_sync(jbus->sbus, jbus->name, jbus->path, jbus->name,
			method, query);
}

/*
 * Synchronous call to 'method' of 'jbus' passing the string 'query'.
 * The returned json response is returned.
 *
 * Returns the json response or NULL in case of error.
 */
struct json_object *jbus_call_sj_sync(
		struct jbus *jbus,
		const char *method,
		const char *query)
{
	struct json_object *obj;
	char *str = jbus_call_ss_sync(jbus, method, query);
	if (str == NULL)
		obj = NULL;
	else {
		jparse(jbus, str, &obj);
		free(str);
	}
	return obj;
}

/*
 * Synchronous call to 'method' of 'jbus' passing the json 'query'.
 * The returned string response is returned.
 *
 * Returns the string response or NULL in case of error.
 */
char *jbus_call_js_sync(
		struct jbus *jbus,
		const char *method,
		struct json_object *query)
{
	const char *str = json_object_to_json_string(query);
	if (str == NULL) {
		errno = ENOMEM;
		return NULL;
	}
	return jbus_call_ss_sync(jbus, method, str);
}

/*
 * Synchronous call to 'method' of 'jbus' passing the json 'query'.
 * The returned json response is returned.
 *
 * Returns the json response or NULL in case of error.
 */
struct json_object *jbus_call_jj_sync(
		struct jbus *jbus,
		const char *method,
		struct json_object *query)
{
	const char *str = json_object_to_json_string(query);
	if (str == NULL) {
		errno = ENOMEM;
		return NULL;
	}
	return jbus_call_sj_sync(jbus, method, str);
}

/*
 * Records for 'jbus' the string signal handler 'onsig' with closure 'data'
 * for the signal of 'name'.
 * The callback handler is called with 2 arguments:
 *   1. char *: the string parameter associated to the signal
 *   2. void *: the closure data.
 *
 * Returns 0 in case of success or -1 otherwise.
 */
int jbus_on_signal_s(
		struct jbus *jbus,
		const char *name,
		void (*onsig) (const char *, void *),
		void *data)
{
	return add_signal(jbus, name, onsig, NULL, data);
}

/*
 * Records for 'jbus' the json signal handler 'onsig' with closure 'data'
 * for the signal of 'name'.
 * The callback handler is called with 2 arguments:
 *   1. struct json_object *: the json parameter associated to the signal
 *   2. void *: the closure data.
 *
 * Returns 0 in case of success or -1 otherwise.
 */
int jbus_on_signal_j(
		struct jbus *jbus,
		const char *name,
		void (*onsig) (struct json_object *, void *),
		void *data)
{
	return add_signal(jbus, name, NULL, onsig, data);
}

/****************** FEW LITTLE TESTS *****************************************/

#if defined(SERVER)||defined(CLIENT)
#include <stdio.h>
#include <unistd.h>
#include "utils-upoll.h"

static int mwait(int timeout, void *closure)
{
	upoll_wait(-1);
	return 0;
}

static const struct sbus_itf uitf = {
	.wait = (void*)mwait,
	.open = (void*)upoll_open,
	.on_readable = (void*)upoll_on_readable,
	.on_writable = (void*)upoll_on_writable,
	.on_hangup = (void*)upoll_on_hangup,
	.close = (void*)upoll_close
};

static struct sbus *sbus;
static struct jbus *jbus;

static struct sbus *msbus()
{
	return sbus ? : (sbus = sbus_session(&uitf, NULL));
}

#ifdef SERVER
void ping(struct sbusmsg *smsg, struct json_object *request, void *unused)
{
	printf("ping(%s) -> %s\n", json_object_to_json_string(request),
	       json_object_to_json_string(request));
	jbus_reply_j(smsg, request);
	json_object_put(request);
}

void incr(struct sbusmsg *smsg, struct json_object *request, void *unused)
{
	static int counter = 0;
	struct json_object *res = json_object_new_int(++counter);
	printf("incr(%s) -> %s\n", json_object_to_json_string(request),
	       json_object_to_json_string(res));
	jbus_reply_j(smsg, res);
	jbus_send_signal_j(jbus, "incremented", res);
	json_object_put(res);
	json_object_put(request);
}

int main()
{
	int s1, s2, s3;
	jbus = create_jbus(msbus(), "/bzh/iot/jdbus");
	s1 = jbus_add_service_j(jbus, "ping", ping, NULL);
	s2 = jbus_add_service_j(jbus, "incr", incr, NULL);
	s3 = jbus_start_serving(jbus);
	printf("started %d %d %d\n", s1, s2, s3);
	while (!mwait(-1,jbus)) ;
	return 0;
}
#endif

#ifdef CLIENT
void onresp(int status, struct json_object *response, void *data)
{
	printf("resp: %d, %s, %s\n", status, (char *)data,
	       json_object_to_json_string(response));
	json_object_put(response);
}

void signaled(const char *content, void *data)
{
	printf("signaled with {%s}/%s\n", content, (char*)data);
}

int main()
{
	int i = 10;
	jbus = create_jbus(msbus(), "/bzh/iot/jdbus");
	jbus_on_signal_s(jbus, "incremented", signaled, "closure-signal");
	while (i--) {
		jbus_call_sj(jbus, "ping", "{\"toto\":[1,2,3,4,true,\"toto\"]}",
			     onresp, "ping");
		jbus_call_sj(jbus, "incr", "{\"doit\":\"for-me\"}", onresp,
			     "incr");
		mwait(-1,jbus);
	}
	printf("[[[%s]]]\n",
	       jbus_call_ss_sync(jbus, "ping", "\"formidable!\""));
	while (!mwait(-1,jbus)) ;
	return 0;
}
#endif
#endif


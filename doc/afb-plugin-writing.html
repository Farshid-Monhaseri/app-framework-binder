<html>
<head>
  <link rel="stylesheet" type="text/css" href="doc.css">
  <meta charset="UTF-8">
</head>
<body>
<a name="HOWTO.WRITE.a.PLUGIN.for.AFB-DAEMON"></a>
<h1>HOWTO WRITE a PLUGIN for AFB-DAEMON</h1>

<pre><code>version: 1
Date:    30 mai 2016
Author:  Jos√© Bollo
</code></pre>

<p><ul>
 <li><a href="#HOWTO.WRITE.a.PLUGIN.for.AFB-DAEMON">HOWTO WRITE a PLUGIN for AFB-DAEMON</a>
 <ul>
  <li><a href="#Summary">Summary</a>
  <ul>
   <li><a href="#Nature.of.a.plugin">Nature of a plugin</a></li>
   <li><a href="#Class.of.plugins">Class of plugins</a>
   <ul>
    <li><a href="#Application-plugins">Application-plugins</a></li>
    <li><a href="#Service-plugins">Service-plugins</a></li>
   </ul>
   </li>
   <li><a href="#Live.cycle.of.plugins.within.afb-daemon">Live cycle of plugins within afb-daemon</a></li>
   <li><a href="#Plugin.Contend">Plugin Contend</a>
   <ul>
    <li><a href="#The.name.of.the.plugin">The name of the plugin</a></li>
    <li><a href="#Names.of.methods">Names of methods</a></li>
    <li><a href="#Initialisation.function">Initialisation function</a></li>
    <li><a href="#Functions.instantiation.of.API.VERBs">Functions instantiation of API/VERBs</a>
</li>
   </ul>
   </li>
  </ul>
  </li>
  <li><a href="#The.Tic-Tac-Toe.example">The Tic-Tac-Toe example</a></li>
  <li><a href="#Dependencies.when.compiling">Dependencies when compiling</a></li>
  <li><a href="#Header.files.to.include">Header files to include</a></li>
  <li><a href="#Choosing.names">Choosing names</a>
  <ul>
   <li><a href="#Names.for.API..plugin.">Names for API (plugin)</a></li>
   <li><a href="#Names.for.methods">Names for methods</a></li>
   <li><a href="#Names.for.arguments">Names for arguments</a></li>
   <li><a href="#Forging.names.widely.available">Forging names widely available</a></li>
  </ul>
  </li>
  <li><a href="#Writing.a.synchronous.method.implementation">Writing a synchronous method implementation</a>
  <ul>
   <li><a href="#The.incoming.request">The incoming request</a></li>
   <li><a href="#Associating.a.client.context.to.a.session">Associating a client context to a session</a></li>
   <li><a href="#Sending.reply.to.a.request">Sending reply to a request</a></li>
  </ul>
  </li>
  <li><a href="#Getting.argument.of.invocation">Getting argument of invocation</a>
  <ul>
   <li><a href="#Basic.functions.for.querying.arguments">Basic functions for querying arguments</a></li>
   <li><a href="#Arguments.for.received.files">Arguments for received files</a></li>
   <li><a href="#Arguments.as.a.JSON.object">Arguments as a JSON object</a></li>
  </ul>
  </li>
  <li><a href="#Initialisation.of.the.plugin.and.declaration.of.methods">Initialisation of the plugin and declaration of methods</a></li>
  <li><a href="#Sending.messages.to.the.log.system">Sending messages to the log system</a>
  <ul>
   <li><a href="#Verbs.for.logging.messages">Verbs for logging messages</a></li>
   <li><a href="#Managing.verbosity">Managing verbosity</a></li>
   <li><a href="#Output.format.and.destination">Output format and destination</a></li>
  </ul>
  </li>
  <li><a href="#Sending.events">Sending events</a></li>
  <li><a href="#Writing.an.asynchronous.method.implementation">Writing an asynchronous method implementation</a></li>
  <li><a href="#How.to.build.a.plugin">How to build a plugin</a>
  <ul>
   <li><a href="#Example.for.cmake.meta.build.system">Example for cmake meta build system</a></li>
   <li><a href="#Exporting.the.function.pluginAfbV1Register">Exporting the function pluginAfbV1Register</a></li>
   <li><a href="#Building.within.yocto">Building within yocto</a></li>
  </ul>
  </li>
 </ul>
 </li>
</ul></p>

<a name="Summary"></a>
<h2>Summary</h2>

<p>Afb-daemon binders serve files through HTTP protocol
and offers to developers the capability to expose application API methods through
HTTP or WebSocket protocol.</p>

<p>Binder plugins are used to add API to afb-daemon.
This part describes how to write a plugin for afb-daemon.</p>

<p>Excepting this summary, this document target developers.</p>

<p>Before moving further through an example, here after
a short overview of binder plugins fundamentals.</p>

<a name="Nature.of.a.plugin"></a>
<h3>Nature of a plugin</h3>

<p>A plugin is an independent piece of software. A plugin is self contain and exposes application logic as sharable library.
A plugin is intended to be dynamically loaded by afb-daemon to expose application API.</p>

<p>Technically, a binder plugin does not reference and is not linked with any afb-daemon library.</p>

<a name="Class.of.plugins"></a>
<h3>Class of plugins</h3>

<p>Application binder supports two kinds of plugins: application plugins and service plugins.
Technically both class of plugin are equivalent are use the same coding convention. Only sharing mode and security context diverge.</p>

<a name="Application-plugins"></a>
<h4>Application-plugins</h4>

<p>Application-plugins implements the glue in between application&rsquo;s UI and services. Every AGL application
has a corresponding binder that typically activates one or many plugins to interface the application logic with lower platform services.
When an application is started by the AGL application framework, a dedicate binder is started that loads/activates application plugin(s).
API expose by application-plugin are executed within corresponding application security context.</p>

<p>Application plugins generally handle a unique context for a unique client. As the application framework start
a dedicated instance of afb_daemon for each AGL application, if a given plugin is used within multiple application each of those
application get a new and private instance of eventually &ldquo;shared&rdquo; plugin.</p>

<a name="Service-plugins"></a>
<h4>Service-plugins</h4>

<p>Service-plugins enable API activation within corresponding service security context and not within calling application context.
Service-plugins are intended to run as a unique instance. Service-plugins can be shared in between multiple clients.</p>

<p>Service-plugins can either be stateless or manage client context. When managing context each client get a private context.</p>

<p>Sharing may either be global to the platform (ie: GPS service) or dedicated to a given user (ie: user preferences)</p>

<a name="Live.cycle.of.plugins.within.afb-daemon"></a>
<h3>Live cycle of plugins within afb-daemon</h3>

<p>Application and service plugins are loaded and activated each time a new afb-daemon is started.</p>

<p>At launch time, every loaded plugin initialise itself.
If a single plugin initialisation fail corresponding instance of afb-daemon self aborts.</p>

<p>Conversely, when a plugin initialisation succeeds, it should register
its unique name as well as the list of verbs attached to the methods it exposes.</p>

<p>When initialised, on request from application clients to the right API/verb, plugin methods
are activated by the afb-daemon attached to the application or service.</p>

<p>At exit time, no special action is enforced by afb-daemon. When a specific actions is required at afb-daemon stop,
developers should use &lsquo;atexit/on_exit&rsquo; during plugin initialisation sequence to register a custom exit function.</p>

<a name="Plugin.Contend"></a>
<h3>Plugin Contend</h3>

<p>Afb-daemon&rsquo;s plugin register two classes of objects: names and functions.</p>

<p>Plugins declare categories of names:
 - A unique plugin name to access all API expose by this plugin,
 - One name for each methods/verbs provided by this plugin.</p>

<p>Plugins declare two categories of functions:
 - function use for the initialisation
 - functions implementing exposed API methods</p>

<p>Afb-daemon parses URI requests to extract the API(plugin name) and the VERB(method to activate).
As an example, URI <strong>foo/bar</strong> translates to plugin named <strong>foo</strong> and method named <strong>bar</strong>.
To serve such a request, afb-daemon looks for an active plugin named <strong>foo</strong> and then within this plugin for a method named <strong>bar</strong>.
When find afb-daemon calls corresponding method with attached parameter if any.</p>

<p>Afb-daemon ignores letter case when parsing URI. Thus <strong>TicTacToe/Board</strong> and <strong>tictactoe/board</strong> are equivalent.</p>

<a name="The.name.of.the.plugin"></a>
<h4>The name of the plugin</h4>

<p>The name of a given plugin is also known as the name
of the API prefix that defines the plugin.</p>

<p>The name of a plugin SHOULD be unique within a given afb-daemon instance.</p>

<p>For example, when a client of afb-daemon calls a URI named <strong>foo/bar</strong>. Afb-daemon
extracts the prefix <strong>foo</strong> and the suffix <strong>bar</strong>. <strong>foo</strong> must match a plugin name and <strong>bar</strong> a VERB attached to some method.</p>

<a name="Names.of.methods"></a>
<h4>Names of methods</h4>

<p>Each plugin exposes a set of methods that can be called
by the clients of a given afb-daemon.</p>

<p>VERB&rsquo;s name attached to a given plugin (API) MUST be unique within a plugin.</p>

<p>Plugins static declaration link VERBS to corresponding methods.
When clients emit requests on a given API/VERB corresponding method is called by afb-daemon.</p>

<a name="Initialisation.function"></a>
<h4>Initialisation function</h4>

<p>Plugin&rsquo;s initialisation function serves several purposes.</p>

<ol>
<li><p>It allows afb-daemon to control plugin version depending on initialisation function name.
As today, the only supported initialisation function is <strong>pluginAfbV1Register</strong>. This identifies
version &ldquo;one&rdquo; of plugins.</p></li>
<li><p>It allows plugins to initialise itself.</p></li>
<li><p>It enables names declarations: descriptions, requirements and implementations of exposed API/VERB.</p></li>
</ol>


<a name="Functions.instantiation.of.API.VERBs"></a>
<h4>Functions instantiation of API/VERBs</h4>

<p>When an API/VERB is called, afb-daemon constructs a request object. Then it
passes this request object to the implementation function corresponding to requested method, this
within attached API plugin.</p>

<p>An implementation function receives a request object that
is used to: get arguments of the request, send
answer, store session data.</p>

<p>A plugin MUST set an answer to every received requests.</p>

<p>Nevertheless it is not mandatory to set the answer
before returning from API/VERB implementing function.
This behaviour is important for asynchronous actions.</p>

<p>API/VERB implementation that set an answer before returning are called <em>synchronous implementations</em>.
Those that do not systematically set an answer before returning are called <em>asynchronous implementations</em>.</p>

<p>Asynchronous implementations typically launch asynchronous actions. They record some context at
request time and provide answer to the request only at completion of asynchronous actions.</p>

<a name="The.Tic-Tac-Toe.example"></a>
<h2>The Tic-Tac-Toe example</h2>

<p>This part explains how to write an afb-plugin.
For the sake of being practical it uses many
examples based on tic-tac-toe.
This plugin example is in <em>plugins/samples/tic-tac-toe.c</em>.</p>

<p>This plugin is named <strong><em>tictactoe</em></strong>.</p>

<a name="Dependencies.when.compiling"></a>
<h2>Dependencies when compiling</h2>

<p>Afb-daemon provides a configuration file for <em>pkg-config</em>.
Typing the command</p>

<pre><code>pkg-config --cflags afb-daemon
</code></pre>

<p>Print flags use for compilation:</p>

<pre><code>$ pkg-config --cflags afb-daemon
-I/opt/local/include -I/usr/include/json-c 
</code></pre>

<p>For linking, you should use</p>

<pre><code>$ pkg-config --libs afb-daemon
-ljson-c
</code></pre>

<p>Afb-daemon automatically includes dependency to json-c.
This is activated through <strong>Requires</strong> keyword in pkg-config.
While almost every plugin replies on <strong>json-c</strong> this is not a must have dependency.</p>

<p>Internally, afb-daemon relies on <strong>libsystemd</strong> for its event loop, as well
as for its binding to D-Bus.
Plugins developers are encouraged to leverage <strong>libsystemd</strong> when possible.
Nevertheless there is no hard dependency to <strong>libsystemd</strong> if ever
you rather not use it, feel free to do so.</p>

<blockquote><p>Afb-daemon plugin are fully self contain. They do not enforce dependency on any libraries from the application framework.
Afb-daemon dependencies requirer to run AGL plugins are given at runtime through pointers leveraging read-only
memory feature.</p></blockquote>

<a name="Header.files.to.include"></a>
<h2>Header files to include</h2>

<p>Plugin <em>tictactoe</em> has following includes:</p>

<pre><code>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;json-c/json.h&gt;
#include &lt;afb/afb-plugin.h&gt;
</code></pre>

<p>Header <em>afb/afb-plugin.h</em> is the only hard dependency, it includes all features
that a plugin MUST HAVE. Outside of includes used to support application logic,
common external headers used within plugins are:</p>

<ul>
<li><em>json-c/json.h</em>: should be include to handle json objects;</li>
<li><em>systemd/sd-event.h</em>: should be include to access event main loop;</li>
<li><em>systemd/sd-bus.h</em>: should be include for dbus connections.</li>
</ul>


<p>The <em>tictactoe</em> plugin does not leverage systemd features, also only json.h
is used on top of mandatory afb/afb-plugin.h.</p>

<p>When including <em>afb/afb-plugin.h</em>, the macro <strong>_GNU_SOURCE</strong> MUST be
defined.</p>

<a name="Choosing.names"></a>
<h2>Choosing names</h2>

<p>Designers of plugins should define a unique name for every API plugin
as well as for methods VERBs. They should also define names for request
arguments passed as name/value pair in URI.</p>

<p>While forging names, designers should respect few rules to
ensure that created names are valid and easy to use across platforms.</p>

<p>All names and strings are UTF-8 encoded.</p>

<a name="Names.for.API..plugin."></a>
<h3>Names for API (plugin)</h3>

<p>Plugin API name are checked.
All characters are authorised except:</p>

<ul>
<li>the control characters (\u0000 .. \u001f)</li>
<li>the characters of the set { &lsquo; &rsquo;, &lsquo;&ldquo;&rsquo;, &lsquo;#&rsquo;, &lsquo;%&rsquo;, &lsquo;&amp;&rsquo;,
&lsquo;&rsquo;&lsquo;, &rsquo;/&lsquo;, &rsquo;?&lsquo;, &rsquo;`&lsquo;, &rsquo;\x7f' }</li>
</ul>


<p>In other words the set of forbidden characters is
{ \u0000..\u0020, \u0022, \u0023, \u0025..\u0027,
  \u002f, \u003f, \u0060, \u007f }.</p>

<p>Afb-daemon makes no distinction between lower case
and upper case when searching for API/VERB.</p>

<a name="Names.for.methods"></a>
<h3>Names for methods</h3>

<p>The names of methods VERBs are totally free and not checked.</p>

<p>However, the validity rules for method&rsquo;s VERB name are the
same as for Plugin API name except that the dot(.) character
is forbidden.</p>

<p>Afb-daemon makes no case distinction when searching for an API by name.</p>

<a name="Names.for.arguments"></a>
<h3>Names for arguments</h3>

<p>Argument&rsquo;s name are not restricted and can be everything you wish.</p>

<blockquote><p>Warning arguments search is case sensitive and &ldquo;index&rdquo; and &ldquo;Index&rdquo;
are not two different arguments.</p></blockquote>

<a name="Forging.names.widely.available"></a>
<h3>Forging names widely available</h3>

<p>The key names of javascript object can be almost
anything using the arrayed notation:</p>

<pre><code>object[key] = value
</code></pre>

<p>Nevertheless this is not the case with javascript dot notation:</p>

<pre><code>object.key = value
</code></pre>

<p>Using the dot notation, the key must be a valid javascript
identifier and dash(-) as well as few other reserved characters cannot be used.</p>

<p>For this reason, we advise developper to chose name compatible with both javascript and HTML notation.</p>

<p>It is a good practice, even for arguments not to rely on case sensitivity.
This may reduce headache strength at debug time, especially with interpreted language like
javascript that may not warn you that a variable was not defined.</p>

<a name="Writing.a.synchronous.method.implementation"></a>
<h2>Writing a synchronous method implementation</h2>

<p>The method <strong>tictactoe/board</strong> is a synchronous implementation.
Here is its listing:</p>

<pre><code>/*
 * get the board
 */
static void board(struct afb_req req)
{
        struct board *board;
        struct json_object *description;

        /* retrieves the context for the session */
        board = board_of_req(req);
        INFO(afbitf, "method 'board' called for boardid %d", board-&gt;id);

        /* describe the board */
        description = describe(board);

        /* send the board's description */
        afb_req_success(req, description, NULL);
}
</code></pre>

<p>This example shows many aspects of a synchronous
method implementation. Let summarise it:</p>

<ol>
<li><p>The function <strong>board_of_req</strong> retrieves the context stored
for the plugin: the board.</p></li>
<li><p>The macro <strong>INFO</strong> sends a message of kind <em>INFO</em>
to the logging system. The global variable named <strong>afbitf</strong>
used represents the interface to afb-daemon.</p></li>
<li><p>The function <strong>describe</strong> creates a json_object representing
the board.</p></li>
<li><p>The function <strong>afb_req_success</strong> sends the reply, attaching to
it the object <em>description</em>.</p></li>
</ol>


<a name="The.incoming.request"></a>
<h3>The incoming request</h3>

<p>For any implementation, the request is received by a structure of type
<strong>struct afb_req</strong>.</p>

<blockquote><p>Note that this is a PLAIN structure, not a pointer to a structure.</p></blockquote>

<p>The definition of <strong>struct afb_req</strong> is:</p>

<pre><code>/*
 * Describes the request by plugins from afb-daemon
 */
struct afb_req {
        const struct afb_req_itf *itf;  /* the interfacing functions */
        void *closure;          /* the closure for functions */
};
</code></pre>

<p>It contains two pointers: first one <em>itf</em>, points to functions used
to handle internal request. Second one <em>closure</em> point onto function closure.</p>

<blockquote><p>The structure must never be used directly.
Instead developer should use the intended functions provided
by afb-daemon as described here after.</p></blockquote>

<p><em>req</em> is used to get arguments of the request, to send
answer, to store session data.</p>

<p>This object and its interface is defined and documented
in the file names <em>afb/afb-req-itf.h</em></p>

<p>The above example uses twice <em>req</em> object request.</p>

<p>The first time, to retrieve the board attached to the session of the request.</p>

<p>The second time, to send the reply: an object that describes the current board.</p>

<a name="Associating.a.client.context.to.a.session"></a>
<h3>Associating a client context to a session</h3>

<p>When <em>tic-tac-toe</em> plugin receives a request, it musts get
the board describing the game associated to the session.</p>

<p>For a plugin, having data associated to a session is common.
This data is called &ldquo;plugin context&rdquo; for the session.
Within <em>tic-tac-toe</em> plugin the context is the board.</p>

<p>Requests <em>afb_req</em> offer four functions for storing and retrieving session associated context.</p>

<p>These functions are:</p>

<ul>
<li><p><strong>afb_req_context_get</strong>:
retrieves context data stored for current plugin.</p></li>
<li><p><strong>afb_req_context_set</strong>:
store context data of current plugin.</p></li>
<li><p><strong>afb_req_context</strong>:
if exist retrieves context data of current plugin.
if context does not yet exist, creates a new context and store it.</p></li>
<li><p><strong>afb_req_context_clear</strong>:
reset the stored context data.</p></li>
</ul>


<p>The plugin <em>tictactoe</em> use a convenient function to retrieve
its context: the board. This function is <em>board_of_req</em>:</p>

<pre><code>/*
 * retrieves the board of the request
 */
static inline struct board *board_of_req(struct afb_req req)
{
        return afb_req_context(req, (void*)get_new_board, (void*)release_board);
}
</code></pre>

<p>The function <strong>afb_req_context</strong> ensures an existing context
for the session of the request.
Its two last arguments are functions to allocate and free context.
Note function type casts to avoid compilation warnings.</p>

<p>Here is the definition of the function <strong>afb_req_context</strong></p>

<pre><code>/*
 * Gets the pointer stored by the plugin for the session of 'req'.
 * If the stored pointer is NULL, indicating that no pointer was
 * already stored, afb_req_context creates a new context by calling
 * the function 'create_context' and stores it with the freeing function
 * 'free_context'.
 */
static inline void *afb_req_context(struct afb_req req, void *(*create_context)(), void (*free_context)(void*))
{
        void *result = afb_req_context_get(req);
        if (result == NULL) {
                result = create_context();
                afb_req_context_set(req, result, free_context);
        }
        return result;
}
</code></pre>

<p>The second argument if the function that creates the context.
For plugin <em>tic-tac-toe</em> (function <strong>get_new_board</strong>).
The function <strong>get_new_board</strong> creates a new board and set usage its count to 1.
The boards are checking usage count to free resources when not used.</p>

<p>The third argument is a function that frees context resources.
For plugin <em>tic-tac-toe</em> (function <strong>release_board</strong>).
The function <strong>release_board</strong> decrease usage count of the board passed in argument.
When usage count falls to zero, data board are freed.</p>

<p>Definition of other functions dealing with contexts:</p>

<pre><code>/*
 * Gets the pointer stored by the plugin for the session of 'req'.
 * When the plugin has not yet recorded a pointer, NULL is returned.
 */
void *afb_req_context_get(struct afb_req req);

/*
 * Stores for the plugin the pointer 'context' to the session of 'req'.
 * The function 'free_context' will be called when the session is closed
 * or if plugin stores an other pointer.
 */
void afb_req_context_set(struct afb_req req, void *context, void (*free_context)(void*));

/*
 * Frees the pointer stored by the plugin for the session of 'req'
 * and sets it to NULL.
 *
 * Shortcut for: afb_req_context_set(req, NULL, NULL)
 */
static inline void afb_req_context_clear(struct afb_req req)
{
        afb_req_context_set(req, NULL, NULL);
}
</code></pre>

<a name="Sending.reply.to.a.request"></a>
<h3>Sending reply to a request</h3>

<p>Two kinds of replies: successful or failure.</p>

<blockquote><p>Sending a reply to a request MUST be done once and only once.</p></blockquote>

<p>It exists two functions for &ldquo;success&rdquo; replies: <strong>afb_req_success</strong> and <strong>afb_req_success_f</strong>.</p>

<pre><code>/*
 * Sends a reply of kind success to the request 'req'.
 * The status of the reply is automatically set to "success".
 * Its send the object 'obj' (can be NULL) with an
 * informationnal comment 'info (can also be NULL).
 *
 * For conveniency, the function calls 'json_object_put' for 'obj'.
 * Thus, in the case where 'obj' should remain available after
 * the function returns, the function 'json_object_get' shall be used.
 */
void afb_req_success(struct afb_req req, struct json_object *obj, const char *info);

/*
 * Same as 'afb_req_success' but the 'info' is a formatting
 * string followed by arguments.
 *
 * For conveniency, the function calls 'json_object_put' for 'obj'.
 * Thus, in the case where 'obj' should remain available after
 * the function returns, the function 'json_object_get' shall be used.
 */
void afb_req_success_f(struct afb_req req, struct json_object *obj, const char *info, ...);
</code></pre>

<p>It exists two functions for &ldquo;failure&rdquo; replies: <strong>afb_req_fail</strong> and <strong>afb_req_fail_f</strong>.</p>

<pre><code>/*
 * Sends a reply of kind failure to the request 'req'.
 * The status of the reply is set to 'status' and an
 * informational comment 'info' (can also be NULL) can be added.
 *
 * Note that calling afb_req_fail("success", info) is equivalent
 * to call afb_req_success(NULL, info). Thus even if possible it
 * is strongly recommended to NEVER use "success" for status.
 *
 * For conveniency, the function calls 'json_object_put' for 'obj'.
 * Thus, in the case where 'obj' should remain available after
 * the function returns, the function 'json_object_get' shall be used.
 */
void afb_req_fail(struct afb_req req, const char *status, const char *info);

/*
 * Same as 'afb_req_fail' but the 'info' is a formatting
 * string followed by arguments.
 *
 * For conveniency, the function calls 'json_object_put' for 'obj'.
 * Thus, in the case where 'obj' should remain available after
 * the function returns, the function 'json_object_get' shall be used.
 */
void afb_req_fail_f(struct afb_req req, const char *status, const char *info, ...);
</code></pre>

<blockquote><p>For conveniency, these functions automatically call <strong>json_object_put</strong> to release <strong>obj</strong>.
Because <strong>obj</strong> usage count is null after being passed to a reply function, it SHOULD not be used anymore.
If exceptionally <strong>obj</strong> needs to remain usable after reply function then using <strong>json_object_get</strong> on <strong>obj</strong>
to increase usage count and cancels the effect the <strong>json_object_put</strong> is possible.</p></blockquote>

<a name="Getting.argument.of.invocation"></a>
<h2>Getting argument of invocation</h2>

<p>Many methods expect arguments. Afb-daemon&rsquo;s plugins
retrieve arguments by name and not by position.</p>

<p>Arguments are passed by requests through either HTTP
or WebSockets.</p>

<p>For example, the method <strong>join</strong> of plugin <strong>tic-tac-toe</strong>
expects one argument: the <em>boardid</em> to join. Here is an extract:</p>

<pre><code>/*
 * Join a board
 */
static void join(struct afb_req req)
{
        struct board *board, *new_board;
        const char *id;

        /* retrieves the context for the session */
        board = board_of_req(req);
        INFO(afbitf, "method 'join' called for boardid %d", board-&gt;id);

        /* retrieves the argument */
        id = afb_req_value(req, "boardid");
        if (id == NULL)
                goto bad_request;
        ...
</code></pre>

<p>The function <strong>afb_req_value</strong> searches in the request <em>req</em>
for argument name passed in the second argument. When argument name
is not passed, <strong>afb_req_value</strong> returns NULL.</p>

<blockquote><p>The search is case sensitive and <em>boardid</em> is not equivalent to <em>BoardId</em>.
Nevertheless having argument names that only differ by name case is not a good idea.</p></blockquote>

<a name="Basic.functions.for.querying.arguments"></a>
<h3>Basic functions for querying arguments</h3>

<p>The function <strong>afb_req_value</strong> is defined here after:</p>

<pre><code>/*
 * Gets from the request 'req' the string value of the argument of 'name'.
 * Returns NULL if when there is no argument of 'name'.
 * Returns the value of the argument of 'name' otherwise.
 *
 * Shortcut for: afb_req_get(req, name).value
 */
static inline const char *afb_req_value(struct afb_req req, const char *name)
{
        return afb_req_get(req, name).value;
}
</code></pre>

<p>It is defined as a shortcut to call the function <strong>afb_req_get</strong>.
That function is defined here after:</p>

<pre><code>/*
 * Gets from the request 'req' the argument of 'name'.
 * Returns a PLAIN structure of type 'struct afb_arg'.
 * When the argument of 'name' is not found, all fields of result are set to NULL.
 * When the argument of 'name' is found, the fields are filled,
 * in particular, the field 'result.name' is set to 'name'.
 *
 * There is a special name value: the empty string.
 * The argument of name "" is defined only if the request was made using
 * an HTTP POST of Content-Type "application/json". In that case, the
 * argument of name "" receives the value of the body of the HTTP request.
 */
struct afb_arg afb_req_get(struct afb_req req, const char *name);
</code></pre>

<p>That function takes 2 parameters: the request and the name
of the argument to retrieve. It returns a PLAIN structure of
type <strong>struct afb_arg</strong>.</p>

<p>There is a special name that is defined when the request is
of type HTTP/POST with a Content-Type being application/json.
This name is <strong>&ldquo;&rdquo;</strong> (the empty string). In that case, the value
of this argument of empty name is the string received as a body
of the post and is supposed to be a JSON string.</p>

<p>The definition of <strong>struct afb_arg</strong> is:</p>

<pre><code>/*
 * Describes an argument (or parameter) of a request
 */
struct afb_arg {
        const char *name;   /* name of the argument or NULL if invalid */
        const char *value;  /* string representation of the value of the argument */
                                /* original filename of the argument if path != NULL */
        const char *path;   /* if not NULL, path of the received file for the argument */
                                /* when the request is finalized this file is removed */
};
</code></pre>

<p>The structure returns the data arguments that are known for the
request. This data include a field named <strong>path</strong>. This <strong>path</strong>
can be accessed using the function <strong>afb_req_path</strong> defined here after:</p>

<pre><code>/*
 * Gets from the request 'req' the path for file attached to the argument of 'name'.
 * Returns NULL if when there is no argument of 'name' or when there is no file.
 * Returns the path of the argument of 'name' otherwise.
 *
 * Shortcut for: afb_req_get(req, name).path
 */
static inline const char *afb_req_path(struct afb_req req, const char *name)
{
        return afb_req_get(req, name).path;
}
</code></pre>

<p>The path is only defined for HTTP/POST requests that send file.</p>

<a name="Arguments.for.received.files"></a>
<h3>Arguments for received files</h3>

<p>As it is explained above, clients can send files using HTTP/POST requests.</p>

<p>Received files are attached to &ldquo;file&rdquo; argument name. For example, the
following HTTP fragment (from test/sample-post.html)
will send an HTTP/POST request to the method
<strong>post/upload-image</strong> with 2 arguments named <em>file</em> and
<em>hidden</em>.</p>

<pre><code>&lt;h2&gt;Sample Post File&lt;/h2&gt;
&lt;form enctype="multipart/form-data"&gt;
    &lt;input type="file" name="file" /&gt;
    &lt;input type="hidden" name="hidden" value="bollobollo" /&gt;
    &lt;br&gt;
    &lt;button formmethod="POST" formaction="api/post/upload-image"&gt;Post File&lt;/button&gt;
&lt;/form&gt;
</code></pre>

<p>Argument named <strong>file</strong> should have both its value and path defined.</p>

<p>The value is the name of the file as it was set by the HTTP client.
Generally it is the filename on client side.</p>

<p>The path is the effective path of saved file on the temporary local storage
area of the application. This is a randomly generated and unique filename.
It is not linked with the original filename as used on client side.</p>

<p>After success the plugin can use the uploaded file directly from local storage path with no restriction:
read, write, remove, copy, rename&hellip;
Nevertheless when request reply is set and query terminated, the uploaded temporary file at
path is destroyed.</p>

<a name="Arguments.as.a.JSON.object"></a>
<h3>Arguments as a JSON object</h3>

<p>Plugins may also request every arguments of a given call as one single object.
This feature is provided by the function <strong>afb_req_json</strong> defined here after:</p>

<pre><code>/*
 * Gets from the request 'req' the json object hashing the arguments.
 * The returned object must not be released using 'json_object_put'.
 */
struct json_object *afb_req_json(struct afb_req req);
</code></pre>

<p>It returns a json object. This object depends on how the request was built:</p>

<ul>
<li><p>For HTTP requests, this json object uses key names mapped on argument name.
Values are either string for common arguments or object ie: { &ldquo;file&rdquo;: &ldquo;&hellip;&rdquo;, &ldquo;path&rdquo;: &ldquo;&hellip;&rdquo; }</p></li>
<li><p>For WebSockets requests, returned directly the object as provided by the client.</p></li>
</ul>


<blockquote><p>In fact, for Websockets requests, the function <strong>afb_req_value</strong>
can be seen as a shortcut to
<strong><em>json_object_get_string(json_object_object_get(afb_req_json(req), name))</em></strong></p></blockquote>

<a name="Initialisation.of.the.plugin.and.declaration.of.methods"></a>
<h2>Initialisation of the plugin and declaration of methods</h2>

<p>To be active, plugin&rsquo;s methods should be declared to
afb-daemon. Furthermore, the plugin itself must be recorded.</p>

<p>The registration mechanism is very basic: when afb-need starts,
it loads all plugins listed in: command line or configuration file.</p>

<p>Loading a plugin follows the following steps:</p>

<ol>
<li><p>Afb-daemon loads the plugin with <em>dlopen</em>.</p></li>
<li><p>Afb-daemon searches for a symbol named <strong>pluginAfbV1Register</strong> using <em>dlsym</em>.
This symbol is assumed to be the exported initialisation function of the plugin.</p></li>
<li><p>Afb-daemon builds an interface object for the plugin.</p></li>
<li><p>Afb-daemon calls the found function <strong>pluginAfbV1Register</strong> with interface pointer
as parameter.</p></li>
<li><p>Function <strong>pluginAfbV1Register</strong> setups the plugin and initialises it.</p></li>
<li><p>Function <strong>pluginAfbV1Register</strong> returns the pointer to a structure
describing the plugin: version, name (prefix or API name), and list of methods.</p></li>
<li><p>Afb-daemon checks that the returned version and name can be managed.
If so, plugin and its methods are register to become usable as soon as
afb-daemon initialisation is finished.</p></li>
</ol>


<p>Here after the code used for <strong>pluginAfbV1Register</strong> from plugin <em>tic-tac-toe</em>:</p>

<pre><code>/*
 * activation function for registering the plugin called by afb-daemon
 */
const struct AFB_plugin *pluginAfbV1Register(const struct AFB_interface *itf)
{
   afbitf = itf;         // records the interface for accessing afb-daemon
   return &amp;plugin_description;  // returns the description of the plugin
}
</code></pre>

<p>It is a very minimal initialisation function because <em>tic-tac-toe</em> plugin doesn&rsquo;t
have any application related initialisation step. It merely record daemon&rsquo;s interface
and returns its description.</p>

<p>The variable <strong>afbitf</strong> is a plugin global variable. It keeps the
interface to afb-daemon that should be used for logging and pushing events.
Here is its declaration:</p>

<pre><code>/*
 * the interface to afb-daemon
 */
const struct AFB_interface *afbitf;
</code></pre>

<p>The description of the plugin is defined here after.</p>

<pre><code>/*
 * array of the methods exported to afb-daemon
 */
static const struct AFB_method_desc_v1 plugin_methods[] = {
   /* VERB'S NAME     SESSION MANAGEMENT          FUNCTION TO CALL  SHORT DESCRIPTION */
   { .name= "new",   .session= AFB_SESSION_NONE, .callback= new,   .info= "Starts a new game" },
   { .name= "play",  .session= AFB_SESSION_NONE, .callback= play,  .info= "Asks the server to play" },
   { .name= "move",  .session= AFB_SESSION_NONE, .callback= move,  .info= "Tells the client move" },
   { .name= "board", .session= AFB_SESSION_NONE, .callback= board, .info= "Get the current board" },
   { .name= "level", .session= AFB_SESSION_NONE, .callback= level, .info= "Set the server level" },
   { .name= "join",  .session= AFB_SESSION_CHECK,.callback= join,  .info= "Join a board" },
   { .name= "undo",  .session= AFB_SESSION_NONE, .callback= undo,  .info= "Undo the last move" },
   { .name= "wait",  .session= AFB_SESSION_NONE, .callback= wait,  .info= "Wait for a change" },
   { .name= NULL } /* marker for end of the array */
};

/*
 * description of the plugin for afb-daemon
 */
static const struct AFB_plugin plugin_description =
{
   /* description conforms to VERSION 1 */
   .type= AFB_PLUGIN_VERSION_1,
   .v1= {               /* fills the v1 field of the union when AFB_PLUGIN_VERSION_1 */
      .prefix= "tictactoe",     /* the API name (or plugin name or prefix) */
      .info= "Sample tac-tac-toe game", /* short description of of the plugin */
      .methods = plugin_methods     /* the array describing the methods of the API */
   }
};
</code></pre>

<p>The structure <strong>plugin_description</strong> describes the plugin.
It declares the type and version of the plugin, its name, a short description
and its methods list.</p>

<p>The list of methods is an array of structures describing the methods and terminated by a NULL marker.</p>

<p>In version one of afb-damon plugin, a method description contains 4 fields:</p>

<ul>
<li><p>the name of the method,</p></li>
<li><p>the session management flags,</p></li>
<li><p>the implementation function to be call for the method,</p></li>
<li><p>a short description.</p></li>
</ul>


<p>The structure describing methods is defined as follows:</p>

<pre><code>/*
 * Description of one method of the API provided by the plugin
 * This enumeration is valid for plugins of type 1
 */
struct AFB_method_desc_v1
{
       const char *name;                       /* name of the method */
       enum AFB_session_v1 session;            /* authorisation and session requirements of the method */
       void (*callback)(struct afb_req req);   /* callback function implementing the method */
       const char *info;                       /* textual description of the method */
};
</code></pre>

<p>For technical reasons, the enumeration <strong>enum AFB_session_v1</strong> is not exactly an
enumeration but the wrapper of constant definitions that can be mixed using bitwise or
(the C operator |).</p>

<p>The constants that can bit mixed are:</p>

<table>
<thead>
<tr>
<th>Constant name            </th>
<th> Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AFB_SESSION_CREATE</strong>   </td>
<td> Equals to AFB_SESSION_LOA_EQ_0|AFB_SESSION_RENEW</td>
</tr>
<tr>
<td><strong>AFB_SESSION_CLOSE</strong>    </td>
<td> Closes the session after the reply and set the LOA to 0</td>
</tr>
<tr>
<td><strong>AFB_SESSION_RENEW</strong>    </td>
<td> Refreshes the token of authentification</td>
</tr>
<tr>
<td><strong>AFB_SESSION_CHECK</strong>    </td>
<td> Just requires the token authentification</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_LE_0</strong> </td>
<td> Requires the current LOA to be lesser then or equal to 0</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_LE_1</strong> </td>
<td> Requires the current LOA to be lesser then or equal to 1</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_LE_2</strong> </td>
<td> Requires the current LOA to be lesser then or equal to 2</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_LE_3</strong> </td>
<td> Requires the current LOA to be lesser then or equal to 3</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_GE_0</strong> </td>
<td> Requires the current LOA to be greater then or equal to 0</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_GE_1</strong> </td>
<td> Requires the current LOA to be greater then or equal to 1</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_GE_2</strong> </td>
<td> Requires the current LOA to be greater then or equal to 2</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_GE_3</strong> </td>
<td> Requires the current LOA to be greater then or equal to 3</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_EQ_0</strong> </td>
<td> Requires the current LOA to be equal to 0</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_EQ_1</strong> </td>
<td> Requires the current LOA to be equal to 1</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_EQ_2</strong> </td>
<td> Requires the current LOA to be equal to 2</td>
</tr>
<tr>
<td><strong>AFB_SESSION_LOA_EQ_3</strong> </td>
<td> Requires the current LOA to be equal to 3</td>
</tr>
</tbody>
</table>


<p>If any of this flag is set, afb-daemon requires an authentication token
as if <strong>AFB_SESSION_CHECK</strong> flag was also set.</p>

<p>The special value <strong>AFB_SESSION_NONE</strong> is zero and can be used to bypass token check.</p>

<blockquote><p>Note that <strong>AFB_SESSION_CREATE</strong> and <strong>AFB_SESSION_CLOSE</strong> might be removed in later versions.</p></blockquote>

<a name="Sending.messages.to.the.log.system"></a>
<h2>Sending messages to the log system</h2>

<p>Afb-daemon provides 4 levels of verbosity and 5 methods for logging messages.</p>

<p>The verbosity is managed. Options allow the change the verbosity of afb-daemon
and the verbosity of the plugins can be set plugin by plugin.</p>

<p>The methods for logging messages are defined as macros that test the
verbosity level and that call the real logging function only if the
message must be output. This avoid evaluation of arguments of the
formatting messages if the message must not be output.</p>

<a name="Verbs.for.logging.messages"></a>
<h3>Verbs for logging messages</h3>

<p>The 5 logging methods are:</p>

<table>
<thead>
<tr>
<th>Macro   </th>
<th style="text-align:center;"> Verbosity </th>
<th> Meaning                           </th>
<th style="text-align:center;"> syslog level</th>
</tr>
</thead>
<tbody>
<tr>
<td>ERROR   </td>
<td style="text-align:center;">     0     </td>
<td> Error conditions                  </td>
<td style="text-align:center;">     3</td>
</tr>
<tr>
<td>WARNING </td>
<td style="text-align:center;">     1     </td>
<td> Warning conditions                </td>
<td style="text-align:center;">     4</td>
</tr>
<tr>
<td>NOTICE  </td>
<td style="text-align:center;">     1     </td>
<td> Normal but significant condition  </td>
<td style="text-align:center;">     5</td>
</tr>
<tr>
<td>INFO    </td>
<td style="text-align:center;">     2     </td>
<td> Informational                     </td>
<td style="text-align:center;">     6</td>
</tr>
<tr>
<td>DEBUG   </td>
<td style="text-align:center;">     3     </td>
<td> Debug-level messages              </td>
<td style="text-align:center;">     7</td>
</tr>
</tbody>
</table>


<p>You can note that the 2 methods <strong>WARNING</strong> and <strong>INFO</strong> have the same level
of verbosity. But they don&rsquo;t have the same <em>syslog level</em>. It means that
they are output with a different level on the logging system.</p>

<p>All of these methods have the same signature:</p>

<pre><code>void ERROR(const struct AFB_interface *afbitf, const char *message, ...);
</code></pre>

<p>The first argument <strong>afbitf</strong> is the interface to afb daemon that the
plugin received at initialisation time when <strong>pluginAfbV1Register</strong> is called.</p>

<p>The second argument <strong>message</strong> is a formatting string compatible with printf/sprintf.</p>

<p>The remaining arguments are arguments of the formating message like with printf.</p>

<a name="Managing.verbosity"></a>
<h3>Managing verbosity</h3>

<p>Depending on the level of verbosity, the messages are output or not.
The following table explains what messages will be output depending
ont the verbosity level.</p>

<table>
<thead>
<tr>
<th style="text-align:center;">Level of verbosity </th>
<th> Outputed macro</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">0          </td>
<td> ERROR</td>
</tr>
<tr>
<td style="text-align:center;">1          </td>
<td> ERROR + WARNING + NOTICE</td>
</tr>
<tr>
<td style="text-align:center;">2          </td>
<td> ERROR + WARNING + NOTICE + INFO</td>
</tr>
<tr>
<td style="text-align:center;">3          </td>
<td> ERROR + WARNING + NOTICE + INFO + DEBUG</td>
</tr>
</tbody>
</table>


<a name="Output.format.and.destination"></a>
<h3>Output format and destination</h3>

<p>The syslog level is used for forging a prefix to the message.
The prefixes are:</p>

<table>
<thead>
<tr>
<th style="text-align:center;">syslog level </th>
<th> prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">0      </td>
<td> <0> EMERGENCY</td>
</tr>
<tr>
<td style="text-align:center;">1      </td>
<td> <1> ALERT</td>
</tr>
<tr>
<td style="text-align:center;">2      </td>
<td> <2> CRITICAL</td>
</tr>
<tr>
<td style="text-align:center;">3      </td>
<td> <3> ERROR</td>
</tr>
<tr>
<td style="text-align:center;">4      </td>
<td> <4> WARNING</td>
</tr>
<tr>
<td style="text-align:center;">5      </td>
<td> <5> NOTICE</td>
</tr>
<tr>
<td style="text-align:center;">6      </td>
<td> <6> INFO</td>
</tr>
<tr>
<td style="text-align:center;">7      </td>
<td> <7> DEBUG</td>
</tr>
</tbody>
</table>


<p>The message is pushed to standard error.
The final destination of the message depends on how systemd service
was configured through its variable <strong>StandardError</strong>. It can be
journal, syslog or kmsg. (See man sd-daemon).</p>

<a name="Sending.events"></a>
<h2>Sending events</h2>

<p>Since version 0.5, plugins can broadcast events to any potential listener.
As today only unattended even are supported. Targeted events are expected for next
coming version.</p>

<p>The plugin <em>tic-tac-toe</em> broadcasts events when the board changes.
This is done in the function <strong>changed</strong>:</p>

<pre><code>/*
 * signals a change of the board
 */
static void changed(struct board *board, const char *reason)
{
        ...
        struct json_object *description;

        /* get the description */
        description = describe(board);

        ...

        afb_daemon_broadcast_event(afbitf-&gt;daemon, reason, description);
}
</code></pre>

<p>The description of the changed board is pushed via the daemon interface.</p>

<p>Within plugin <em>tic-tac-toe</em>, <em>reason</em> indicates the origin of
the change. In function <strong>afb_daemon_broadcast_event</strong> the second
parameter is the name of broadcasted event. The third argument is the
object that is transmitted with the event.</p>

<p>Function <strong>afb_daemon_broadcast_event</strong> is defined here after:</p>

<pre><code>/*
 * Broadcasts widely the event of 'name' with the data 'object'.
 * 'object' can be NULL.
 * 'daemon' MUST be the daemon given in interface when activating the plugin.
 *
 * For conveniency, the function calls 'json_object_put' for 'object'.
 * Thus, in the case where 'object' should remain available after
 * the function returns, the function 'json_object_get' shall be used.
 */
void afb_daemon_broadcast_event(struct afb_daemon daemon, const char *name, struct json_object *object);
</code></pre>

<blockquote><p>Be aware, as with reply functions <strong>object</strong> is automatically released using
<strong>json_object_put</strong> when using this function. Call <strong>json_object_get</strong> before
calling <strong>afb_daemon_broadcast_event</strong> to keep <strong>object</strong> available
after function returns.</p></blockquote>

<p>Event name received by listeners is prefixed with plugin name.
So when a change occurs after a move, the reason is <strong>move</strong> and every clients
receive an event <strong>tictactoe/move</strong>.</p>

<blockquote><p>Note that nothing is said about case sensitivity of event names.
However, the event is always prefixed with the name that the plugin
declared, with the same case, followed with a slash /.
Thus it is safe to compare event using a case sensitive comparison.</p></blockquote>

<a name="Writing.an.asynchronous.method.implementation"></a>
<h2>Writing an asynchronous method implementation</h2>

<p>The <em>tic-tac-toe</em> example allows two clients or more to share the same board.
This is implemented by the method <strong>join</strong> that illustrated partly how to
retrieve arguments.</p>

<p>When two or more clients are sharing a same board, one of them can wait
until the state of the board changes, but this could also be implemented using
events because an even is generated each time the board changes.</p>

<p>In this case, the reply to the wait is sent only when the board changes.
See the diagram below:</p>

<pre><code>CLIENT A       CLIENT B         TIC-TAC-TOE
   |              |                  |
   +--------------|-----------------&gt;| wait . . . . . . . .
   |              |                  |                     .
   :              :                  :                      .
   :              :                  :                      .
   |              |                  |                      .
   |              +-----------------&gt;| move . . .           .
   |              |                  |          V           .
   |              |&lt;-----------------+ success of move      .
   |              |                  |                    .
   |&lt;-------------|------------------+ success of wait  &lt;
</code></pre>

<p>Here, this is an invocation of the plugin by an other client that
unblock the suspended <em>wait</em> call.
Nevertheless in most case this should be a timer, a hardware event, a sync with
a concurrent process or thread, &hellip;</p>

<p>Common case of an asynchronous implementation.</p>

<p>Here is the listing of the function <strong>wait</strong>:</p>

<pre><code>static void wait(struct afb_req req)
{
        struct board *board;
        struct waiter *waiter;

        /* retrieves the context for the session */
        board = board_of_req(req);
        INFO(afbitf, "method 'wait' called for boardid %d", board-&gt;id);

        /* creates the waiter and enqueues it */
        waiter = calloc(1, sizeof *waiter);
        waiter-&gt;req = req;
        waiter-&gt;next = board-&gt;waiters;
        afb_req_addref(req);
        board-&gt;waiters = waiter;
}
</code></pre>

<p>After retrieving the board, the function adds a new waiter to
waiters list and returns without setting a reply.</p>

<p>Before returning, it increases <strong>req</strong> request&rsquo;s reference count using <strong>afb_req_addref</strong> function.</p>

<blockquote><p>When a method returns without setting a reply,
it <strong>MUST</strong> increment request&rsquo;s reference count
using <strong>afb_req_addref</strong>. If unpredictable behaviour may pop up.</p></blockquote>

<p>Later, when a board changes, it calls <em>tic-tac-toe</em> <strong>changed</strong> function
with reason of change in parameter.</p>

<p>Here is the full listing of the function <strong>changed</strong>:</p>

<pre><code>/*
 * signals a change of the board
 */
static void changed(struct board *board, const char *reason)
{
        struct waiter *waiter, *next;
        struct json_object *description;

        /* get the description */
        description = describe(board);

        waiter = board-&gt;waiters;
        board-&gt;waiters = NULL;
        while (waiter != NULL) {
                next = waiter-&gt;next;
                afb_req_success(waiter-&gt;req, json_object_get(description), reason);
                afb_req_unref(waiter-&gt;req);
                free(waiter);
                waiter = next;
        }

        afb_event_sender_push(afb_daemon_get_event_sender(afbitf-&gt;daemon), reason, description);
}
</code></pre>

<p>The list of waiters is walked and a reply is sent to each waiter.
After sending the reply, the reference count of the request
is decremented using <strong>afb_req_unref</strong> to allow resources to be freed.</p>

<blockquote><p>The reference count <strong>MUST</strong> be decremented using <strong>afb_req_unref</strong> to free
resources and avoid memory leaks.
This usage count decrement should happen <strong>AFTER</strong> setting reply or
bad things may happen.</p></blockquote>

<a name="How.to.build.a.plugin"></a>
<h2>How to build a plugin</h2>

<p>Afb-daemon provides a <em>pkg-config</em> configuration file that can be
queried by providing <strong>afb-daemon</strong> in command line arguments.
This configuration file provides data that should be used
for plugins compilation. Examples:</p>

<pre><code>$ pkg-config --cflags afb-daemon
$ pkg-config --libs afb-daemon
</code></pre>

<a name="Example.for.cmake.meta.build.system"></a>
<h3>Example for cmake meta build system</h3>

<p>This example is the extract for building the plugin <em>afm-main</em> using <em>CMAKE</em>.</p>

<pre><code>pkg_check_modules(afb afb-daemon)
if(afb_FOUND)
        message(STATUS "Creation afm-main-plugin for AFB-DAEMON")
        add_library(afm-main-plugin MODULE afm-main-plugin.c)
        target_compile_options(afm-main-plugin PRIVATE ${afb_CFLAGS})
        target_include_directories(afm-main-plugin PRIVATE ${afb_INCLUDE_DIRS})
        target_link_libraries(afm-main-plugin utils ${afb_LIBRARIES})
        set_target_properties(afm-main-plugin PROPERTIES
                PREFIX ""
                LINK_FLAGS "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/afm-main-plugin.export-map"
        )
        install(TARGETS afm-main-plugin LIBRARY DESTINATION ${plugin_dir})
else()
        message(STATUS "Not creating the plugin for AFB-DAEMON")
endif()
</code></pre>

<p>Let now describe some of these lines.</p>

<pre><code>pkg_check_modules(afb afb-daemon)
</code></pre>

<p>This first lines searches to the <em>pkg-config</em> configuration file for
<strong>afb-daemon</strong>. Resulting data are stored in the following variables:</p>

<table>
<thead>
<tr>
<th>Variable          </th>
<th> Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>afb_FOUND         </td>
<td> Set to 1 if afb-daemon plugin development files exist</td>
</tr>
<tr>
<td>afb_LIBRARIES     </td>
<td> Only the libraries (w/o the &lsquo;-l&rsquo;) for compiling afb-daemon plugins</td>
</tr>
<tr>
<td>afb_LIBRARY_DIRS  </td>
<td> The paths of the libraries (w/o the &lsquo;-L&rsquo;) for compiling afb-daemon plugins</td>
</tr>
<tr>
<td>afb_LDFLAGS       </td>
<td> All required linker flags for compiling afb-daemon plugins</td>
</tr>
<tr>
<td>afb_INCLUDE_DIRS  </td>
<td> The &lsquo;-I&rsquo; preprocessor flags (w/o the &lsquo;-I&rsquo;) for compiling afb-daemon plugins</td>
</tr>
<tr>
<td>afb_CFLAGS        </td>
<td> All required cflags for compiling afb-daemon plugins</td>
</tr>
</tbody>
</table>


<p>If development files are found, the plugin can be added to the set of
target to build.</p>

<pre><code>add_library(afm-main-plugin MODULE afm-main-plugin.c)
</code></pre>

<p>This line asks to create a shared library having a single
source file named afm-main-plugin.c to be compiled.
The default name of the created shared object is
<strong>libafm-main-plugin.so</strong>.</p>

<pre><code>set_target_properties(afm-main-plugin PROPERTIES
        PREFIX ""
        LINK_FLAGS "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/afm-main-plugin.export-map"
)
</code></pre>

<p>This lines are doing two things:</p>

<ol>
<li><p>It renames the built library from <strong>libafm-main-plugin.so</strong> to <strong>afm-main-plugin.so</strong>
by removing the implicitly added prefix <em>lib</em>. This step is not mandatory
because afb-daemon doesn&rsquo;t check names of files at load time.
The only filename convention used by afb-daemon relates to <strong>.so</strong> termination.
*.so pattern is used when afb-daemon automatically discovers plugin from a directory hierarchy.</p></li>
<li><p>It applies a version script at link time to only export the reserved name
<strong>pluginAfbV1Register</strong> for registration entry point. By default, when building
a shared library linker exports all the public symbols (C functions that are not <strong>static</strong>).</p></li>
</ol>


<p>Next line are:</p>

<pre><code>target_include_directories(afm-main-plugin PRIVATE ${afb_INCLUDE_DIRS})
target_link_libraries(afm-main-plugin utils ${afb_LIBRARIES})
</code></pre>

<p>As you can see it uses the variables computed by <strong><em>pkg_check_modules(afb afb-daemon)</em></strong>
to configure the compiler and the linker.</p>

<a name="Exporting.the.function.pluginAfbV1Register"></a>
<h3>Exporting the function pluginAfbV1Register</h3>

<p>The function <strong>pluginAfbV1Register</strong> MUST be exported. This can be achieved
using a version script at link time. Here after is a version script used for
<em>tic-tac-toe</em> (plugins/samples/export.map).</p>

<pre><code>{ global: pluginAfbV1Register; local: *; };
</code></pre>

<p>This sample <a href="https://sourceware.org/binutils/docs-2.26/ld/VERSION.html#VERSION">version script</a>
exports as global the symbol <em>pluginAfbV1Register</em> and hides any
other symbols.</p>

<p>This version script is added to the link options using the
option <strong>&ndash;version-script=export.map</strong> is given directly to the
linker or using the option <strong>-Wl,&ndash;version-script=export.map</strong>
when the option is given to the C compiler.</p>

<a name="Building.within.yocto"></a>
<h3>Building within yocto</h3>

<p>Adding a dependency to afb-daemon is enough. See below:</p>

<pre><code>DEPENDS += " afb-daemon "
</code></pre>
</body>
</html>
